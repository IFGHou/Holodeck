/*
	$USER_PROJECT_NAME$.cpp
	Code file for the test executable
	Generated by Holodeck Custom Intercept Project Generator
*/


#include <stdio.h>
#include <conio.h>
#include <tchar.h>
#include <windows.h>
#include <string.h>
#include "$USER_PROJECT_NAME$.h"

#using <mscorlib.dll>
#using "$INSTALL_PATH$\\HolodeckLib.dll"
#using "$INSTALL_PATH$\\FunctionDatabase.dll"

using namespace System;
using namespace System::IO;
using namespace HolodeckLib;
using namespace FunctionDatabase;

bool interceptFunctions(HolodeckLib::TestApplication  * testApp);

//************************************************************************
// Method Name: _tmain
// Description: Entry point for the program
//
// Params: None
//
// Return Value: (int) -1 if error
//************************************************************************
int _tmain(void)
{
	HolodeckLib::TestApplication  * testApp = new HolodeckLib::TestApplication();

	//Intercept the functions
	if (!interceptFunctions (testApp))
		return -1;

	#IF_PROCESS_CHAINING#testApp->SetUseProcessChaining(true);

	@ATTACH_OR_LAUNCH
		
	//This will Pause the application
	//testApp->PauseApplication();

	//This will Resume the application
	//testApp->ResumeApplication();

	//This will inject a fault
	//testApp->InjectFault (NULL, DiskFaults::Disk_Full);

	//This will remove a fault
	//testApp->RemoveFault (NULL, DiskFaults::Disk_Full);

	printf ("Press any key to terminate and exit.\n");
	getch();
	
	//This will terminate the application
	testApp->TerminateApplication();
	
	exit (0);
}

//************************************************************************
// Method Name: interceptFunctions 
// Description: Intercepts the functions requested by the user
//
// Params:
//	testApp - the HolodeckLib to use for interception
//
//
// Return Value: (bool) true if successful, false on error
//************************************************************************
bool interceptFunctions (HolodeckLib::TestApplication  * testApp)
{
	//Verify and save path to $USER_PROJECT_NAME$Dll.dll
	char replacementLibrary[MAX_PATH];
	GetCurrentDirectory (MAX_PATH, replacementLibrary);
	if (File::Exists (String::Concat (Environment::CurrentDirectory, Path::DirectorySeparatorChar.ToString(), "$USER_PROJECT_NAME$Dll.dll")))
		strcat (replacementLibrary, "\\$USER_PROJECT_NAME$Dll.dll");
	else if (File::Exists (String::Concat (Environment::CurrentDirectory, Path::DirectorySeparatorChar.ToString(), "Output\\$USER_PROJECT_NAME$Dll.dll")))
		strcat (replacementLibrary, "\\Output\\$USER_PROJECT_NAME$Dll.dll");
	else
	{
		MessageBox (NULL, "$USER_PROJECT_NAME$Dll.dll not found! Please run $USER_PROJECT_NAME$.exe from the directory which contains $USER_PROJECT_NAME$Dll.dll", "Error", 0);
		return false;
	}

	//Call interception routines on all selected methods
	@INTERCEPT_FUNCTIONS

	return true;
}
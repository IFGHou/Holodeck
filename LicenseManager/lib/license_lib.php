<?php

/**
 * all of the constants and functions necessary to generate registration keys, 
 * verify and decode registration keys.
 * This code was ported from the .NET RegKeyGenerator utility in the Holodeck source
 */

define('NO_TIME_EXPIRATION', 0);
define('SITE_LICENSE', 0);
define('ASCII_ZERO', 48);
define('MIN_SERIAL_NUMBER_LENGTH', 7);
define('ASCII_BIG_A', 65);
define('NUM_LETTERS', 26);
define('INDEX_OFFSET', 67);


// seed with microseconds
function make_seed()
{
	list($usec, $sec) = explode(' ', microtime());
	return (float) $sec + ((float) $usec * 100000);
}


/**
 * holds a license record
 */
class RegistrationData
{
	var $numberOfLicensesPurchased; //unsigned long
	var $numberOfDaysValid;         //long
	var $keyVersion;                //RegKeyVersion
	var $customerType;              //CustomerType
	var $productType;               //ProductType
	var $functionalityType;         //FunctionalityType

	var $serialNumber;              //string
	var $registrationKey;           //string
};

srand(make_seed());


/**
 * generates a byte array based on the encoding of the serial number
 *
 * MR: Note: if the serial number does not contain an even number of characters
 *           in the string, the last character will be ignored when generating 
 *           the byte array.
 *
 * MR: Note: the generated byte array consists entirely of uppercase alpha 
 *           characters only.
 * Parameters:
 *	serial_number - the serial number to generate the byte array for
 *
 * Return Value: string representing the encoded serial number on exit
 */
function GenerateSerialNumberByteArray($serial_number)
{
	// get rid of spaces and dashes
	$buffer = str_replace('-', '', $serial_number);
	$buffer = str_replace(' ', '', $buffer);

	$byteArray = "";
	for ($i = 0; $i < strlen($buffer) - 1; $i += 2)
	{
		$byte = ((ord($buffer[$i]) - ASCII_ZERO) * 10) + (ord($buffer[$i+1]) - ASCII_ZERO);
		$byteArray .= chr(($byte % NUM_LETTERS) + ASCII_BIG_A);
	}

	return $byteArray;
}


/**
 * encodes a number value and returns the encoded string
 * 
 * MR: Note: size of encoded integer is represented as 1 + (value/260)+1
 *
 * Parameters:
 * value - the value to encode
 * 
 * Return Value: resulting encoded string
 */
function EncodeNumber($value)
{
	$encodedValue = "";
	$modulus = $value % NUM_LETTERS;
	$multiplier = $value / NUM_LETTERS;
	$multiplierDigits = 0;
	$done = false;

	while (!$done){
		$digit = $multiplier % 10;
		$temp = chr($digit + ASCII_BIG_A);
		$temp .= $encodedValue;
		$encodedValue = $temp;
		$multiplierDigits++;
		if ($multiplier < 10)
		{
			$done = true;
		}
		$multiplier = $multiplier / 10;
	}

	$encodedValue = chr($multiplierDigits + ASCII_BIG_A) . $encodedValue;
	$encodedValue .= chr($modulus + ASCII_BIG_A);

	return $encodedValue;
}


/**
 * Method: InsertIntoByteArray
 * Description: inserts an encoded string into the byte array
 * number
 *
 * Parameters:
 *	byteArray - the string to insert into
 *	pos - the position to insert the value
 *	value - the value to insert
 *	encodeLength - true if the length should be encoded as well
 *
 * Return Value: None
 */
function InsertIntoByteArray($byteArray, $pos, $value, $encodeLength)
{
	$encodedValue = "";

	if ($encodeLength == true)
	$encodedValue = EncodeNumber($value);
	else
	$encodedValue = chr($value + ASCII_BIG_A);

	$leftPart = "";
	$rightPart = "";

	if ($pos > 0)
	$leftPart = substr($byteArray, 0, $pos);

	$rightPart = substr($byteArray, $pos, strlen($byteArray) - $pos);
	$byteArray = $leftPart . $encodedValue . $rightPart . chr($pos + INDEX_OFFSET);

	return $byteArray;
}


//void test_encode_holodeck_basic_key(const SiString &serialNumber, SiString &resultKey)
function encode_holodeck_basic_key($registration_data)
{
	// Create a byte array by using numbered pairs from the serial number.
	$byteArray = GenerateSerialNumberByteArray($registration_data->serialNumber);

	//MR: if number of days valid equals 0, key does not expire
	// insert the number of days til expiration
	$index = rand() % strlen($byteArray);
	$byteArray = InsertIntoByteArray($byteArray, $index, $registration_data->numberOfDaysValid, true);

	//MR: if number of licenses purchased equals 0, this is a site license
	// insert the number of licenses purchased
	$index = rand() % strlen($byteArray);
	$byteArray = InsertIntoByteArray($byteArray, $index, $registration_data->numberOfLicensesPurchased, true);

	// insert the functionality level
	$index = rand() % strlen($byteArray);
	$byteArray = InsertIntoByteArray($byteArray, $index, $registration_data->functionalityType, false);

	// insert the customer type
	$index = rand() % strlen($byteArray);
	$byteArray = InsertIntoByteArray($byteArray, $index, $registration_data->customerType, false);

	return $byteArray;
}


/**
 * Method:		GenerateChecksum
 * Description: generate a checksum by xor-ing each character in the string
 *	this reduces the likelihood that a key will be hacked
 *
 * Parameters:
 *	byteArray - The string to generate the checksum for
 *
 * Return Value: the checksum value
 */
function generate_checksum($byteArray)
{
	$byte = 0;
	$arr = $byteArray;
	for ($i = 0; $i < strlen($byteArray); $i++)
	{
		$byte ^= ord($arr[$i]);
	}
	return $byte % NUM_LETTERS;
}


function generate_registration_key($registration_data)
{
	$serialNumber = $registration_data->serialNumber;

	if (strlen($serialNumber) < MIN_SERIAL_NUMBER_LENGTH)
	return false;

	// clear out the strings
	$registrationKey = "";

	$byteArray = encode_holodeck_basic_key($registration_data);

	// insert the product type
	$index = rand() % strlen($byteArray);
	$byteArray = InsertIntoByteArray($byteArray, $index, $registration_data->productType, false);

	// insert the key version
	$index = rand() % strlen($byteArray);
	$byteArray = InsertIntoByteArray($byteArray, $index, $registration_data->keyVersion, false);

	// generate the checksum
	$checksum = generate_checksum($byteArray);
	$byteArray .= chr($checksum + ASCII_BIG_A);

	$result = "";
	// insert dashes every 5 chars for readability
	for ($i = 0; $i < strlen($byteArray); $i += 5)
	{
		$left = substr($byteArray, $i, 5);
		$result .= $left;

		if($i+5 <strlen($byteArray))
		$result .= '-';
	}

	$registration_data->registrationKey = $result;
	return $registration_data;
}



/////////////////////////////////////
//decoding functions follow...


/**
 * Method:		DecodeNumber
 * Description: decodes a number value from a byte array and returns the
 * value
 * 
 * Parameters:
 * byteArray - the string with the number to decode
 * index - the position in the byte array to start decoding
 * 
 * Return Value: an array containing the value extracted from the string 
 *               in index 0 and the length of the extracted value in 
 *               index 1, or -1 on error
 */
function DecodeNumber($byteArray, $index)
{
	$multiplier = 0;

	if ($index > strlen($byteArray))
	{
		return -1;
	}

	// extract the size of the multiplier
	$multiplierDigits = ord($byteArray[$index++]) - ASCII_BIG_A;

	// extract the multiplier
	while ($multiplierDigits > 0)
	{
		if ($index > strlen($byteArray) - 1)
		{
			return -1;
		}
		$multiplier = ($multiplier * 10) + ord($byteArray[$index++]) - ASCII_BIG_A;
		$multiplierDigits--;
	}

	if ($index > strlen($byteArray) - 1)
	{
		return -1;
	}

	// extract the modulus
	$modulus = ord($byteArray[$index]) - ASCII_BIG_A;

	// compute the return value
	return array( ($multiplier * NUM_LETTERS + $modulus), $index );
}


/**
 * extracts an encoded string from the byte array as a number.
 *	This method is the reverse of InsertIntoByteArray
 *
 * Parameters:
 *	byteArray - the string to extract from
 *	lengthEncoded - true if the length was be encoded
 *
 * Return Value: array consisting of the modified string at index 0 and the extracted value at index 1
 *               returns -1 on error
 */
function ExtractFromByteArray($byteArray, $lengthEncoded)
{
	// get the index.  if it is invalid return an error
	$index = ord($byteArray[strlen($byteArray) - 1]) - INDEX_OFFSET;

	if (($index > (strlen($byteArray) - 1)) || ($index < 0))
	return -1;

	$value = 0;
	if ($lengthEncoded)
	{
		list($value, $length) = DecodeNumber($byteArray, $index);
	}
	else
	{
		$value = ord($byteArray[$index]) - ASCII_BIG_A;
		$length = $index;
	}

	//SiString left, right;
	if ($index == 0)
	{
		$left = "";
	}
	else
	{
		$left = substr($byteArray, 0, $index);
	}

	$right = substr($byteArray, $length + 1, strlen($byteArray));
	$right = substr($right, 0, strlen($right) - 1);
	$byteArray = $left . $right;

	return array($byteArray, $value);
}




/**
 * decodes a holodeck basic key
 *
 * @param $key - the string containing the key to decode
 *
 * Return Value: a RegistrationData structure if successful, false otherwise
 */
function DecodeHolodeckBasicKey($key)
{
	$value = 0;

	// get the customer type
	list($key, $value) = ExtractFromByteArray($key, false);
	if ($value == -1)
	{
		return false;
	}

	$data = new RegistrationData();
	$data->customerType = $value;

	// get the functionality level
	list($key, $value) = ExtractFromByteArray($key, false);
	if ($value == -1)
	{
		return false;
	}
	$data->functionalityType = $value;

	// get the number of licenses purchased
	list($key, $value) = ExtractFromByteArray($key, true);
	if ($value == -1)
	{
		return false;
	}
	$data->numberOfLicensesPurchased = $value;

	// get the days til expiration
	list($key, $value) = ExtractFromByteArray($key, true);
	if ($value == -1)
	{
		return false;
	}
	$data->numberOfDaysValid = $value;

	return array($data, $key);
}



/*************************************************************************
* Method:		DecodeRegistrationKey
* Description: decodes a serial number/registration key combination.  you
* must fill in the serial number and registration key fields of the data
* parameter for this to work
*
* Parameters:
* data - The registration data to decode from.  Fill in the serial number
* and registration key fields before calling this function.  On exit
* of the function, this parameter will have all its fields filled in.
*
* Return Value: RegistrationData instance with fields filled in if successful, false otherwise
*/
//bool RegistrationKeyGenerator::DecodeRegistrationKey(RegistrationData *data)
function DecodeRegistrationKey($serial_number, $registration_key)
{
	if ((strlen($serial_number) == 0) || (strlen($registration_key) == 0))
	{
		return false;
	}

	$key = $registration_key;
	$key = str_replace('-', '', $key);
	$key = str_replace(' ', '', $key);
	$key = strtoupper($key);

	// get the checksum from the key.  It will be the last char of the key
	$checksumFromKey = ord($key[strlen($key) - 1]) - ASCII_BIG_A;
	$key = substr($key, 0, strlen($key) - 1);

	// store off this key so we can compare checksum later
	$keyToCompareChecksumTo = $key;

	list($key, $version) = ExtractFromByteArray($key, false);
	list($key, $product) = ExtractFromByteArray($key, false);
	if (($version == -1) || ($product == -1))
	{
		return false;
	}

	// decode the rest of the key
	$arr = DecodeHolodeckBasicKey($key);
	if (!$arr)
	{
		return false;
	}
	$data = $arr[0];
	$key = $arr[1];
	$data->productType = $product;
	$data->keyVersion = $version;
	$data->serialNumber = $serial_number;
	$data->registrationKey = $registration_key;

	//make sure that what is left of the key matches the serial number encoding
	$computedSerialNumber = GenerateSerialNumberByteArray($data->serialNumber);
	if ($computedSerialNumber != $key)
	{
		return false;
	}

	// check the original checksum with the computed checksum to make sure it is valid
	$computedChecksum = generate_checksum($keyToCompareChecksumTo);
	if ($computedChecksum != $checksumFromKey)
	{
		return false;
	}

	return $data;
}



function get_customer_type_name($id)
{
	$query = "SELECT CustomerType FROM CustomerTypes WHERE ID = $id";
	$result = mysql_query($query);
	if($result)
	{
		$row = mysql_fetch_row($result);
		mysql_free_result($result);      //free the result set
		return $row[0];
	}

	return FALSE;
}

function get_functionality_type_name($id)
{
	$query = "SELECT FunctionalityLevel FROM Functionality WHERE ID = $id";
	$result = mysql_query($query);
	if($result)
	{
		$row = mysql_fetch_row($result);
		mysql_free_result($result);      //free the result set
		return $row[0];
	}
	return FALSE;
}

function get_product_type_name($id)
{
	$query = "SELECT ProductName FROM Products WHERE ID = $id";
	$result = mysql_query($query);
	if($result)
	{
		$row = mysql_fetch_row($result);
		mysql_free_result($result);      //free the result set
		return $row[0];
	}

	return FALSE;
}

function get_key_type_name($id)
{
	$query = "SELECT KeyVersion FROM KeyVersions WHERE ID = $id";
	$result = mysql_query($query);
	if($result)
	{
		$row = mysql_fetch_row($result);
		mysql_free_result($result);      //free the result set
		return $row[0];
	}

	return FALSE;
}

?>